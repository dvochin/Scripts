/*###DISCUSSION: Soft Body / PhysX
=== NEXT ===
- For character edit mode have a mode without softbody entity?  (Just for morph?)
 
=== TODO ===

=== LATER ===

=== IMPROVE ===

=== DESIGN ===

=== IDEAS ===

=== LEARNED ===

=== PROBLEMS ===
 * GPU on softbody not working!! WTF???  Has to be offline?  Used to work!  ####SOON

=== PROBLEMS??? ===

=== WISHLIST ===

*/

using UnityEngine;
using System;
using System.Collections.Generic;


public class CBSoft : CBMesh, IObject {					//####DEV ####DESIGN: Based on CBMesh or CBSkin??
	// Manages a single soft body object send to our PhysX implementation for soft body simulation.  These 'body parts' (such as breasts, penis, vagina) 
	//... are conneted to the main body skinned mesh via _oMeshRimBaked which pins this softbody's tetraverts to those skinned from the main body

	//---------------------------------------------------------------------------	MEMBERS
	[HideInInspector]	public 	CObject				_oObj;							// The multi-purpose CObject that stores CProp properties  to publicly define our object.  Provides client/server, GUI and scripting access to each of our 'super public' properties.
	[HideInInspector]	public	CBSkinBaked			_oMeshRimBaked;					// The skinned 'rim mesh' that is baked everyframe.  Contains rim and tetraverts.  Rim is to adjust normals at softbody mesh boundary and the tetraverts in this mesh are to 'pin' our softbody tetraverts to the skinned body (so softbody doesn't go 'flying off')
	
	[HideInInspector]	public	List<ushort>		_aMapTwinVerts = new List<ushort>();		// Collection of mapping between our verts and the verts of our BodyRim.  Used to set softbody mesh rim verts and normals to their skinned-equivalent
	[HideInInspector]	public	List<ushort>		_aMapRimTetravert2Tetravert;	// Map of rim tetraverts to tetraverts.  Used to translate between our 'rim + close tetraverts' to PhysX2 softbody tetraverts. (To pin some tetraverts to skinned body)
	
	//---------------------------------------------------------------------------	PhysX-related properties sent during BSoft_Init()
	[HideInInspector]	public	string				_sNameSoftBody;				// The name of our 'detached chunk' in Blender.  ('Breasts', 'Penis', 'Vagina') from a substring of our class name.  Must match Blender!!
	[HideInInspector]	public  int					_SoftBodyDetailLevel;			// Detail level of the associated PhysX tetramesh... a range between 20 (low) and 50 (very high) is reasonable
	[HideInInspector]	public	EColGroups			_eColGroup;						// The PhysX collider group for this softbody.  Used to properly determine what this softbody collides with...
	[HideInInspector]	public	float				_nRangeTetraPinHunt = 0.025f;	// The maximum distance between the rim mesh and the tetraverts generated by PhysX2.  Determins which softbody tetraverts are 'pinned' to the skinned body

	//---------------------------------------------------------------------------	MISC
	[HideInInspector]	public	EGameModes			_eGameModeSoftBody = EGameModes.None;		// The last-configured game mode for this softbody.  (e.g. 'Where we're at now')



	//---------------------------------------------------------------------------	INIT

	public CBSoft() {                           // Setup the default arguments... usually overriden by our derived class   //###BUG??? Why are these settings not overriding those in instanced node???
		_nRangeTetraPinHunt = 0.025f;
	}

	public static CBSoft Create(CBody oBody, Type oTypeBMesh) { 
		string sNameSoftBody = oTypeBMesh.Name.Substring(1);                            // Obtain the name of our detached body part ('Breasts', 'Penis', 'Vagina') from a substring of our class name.  Must match Blender!!  ###WEAK?
		CGame.gBL_SendCmd("CBody", "CBody_GetBody(" + oBody._nBodyID.ToString() + ").CreateSoftBody('" + sNameSoftBody + "')");		// Separate the softbody from the source body.
		CBSoft oBSoft = (CBSoft)CBMesh.Create(null, oBody, "aSoftBodies['" + sNameSoftBody + "'].oMeshSoftBody", oTypeBMesh);		// Create the softbody mesh from the just-created Blender mesh.
		return oBSoft;
	}

	public override void OnDeserializeFromBlender() {
		base.OnDeserializeFromBlender();

		_sNameSoftBody = GetType().Name.Substring(1);                            // Obtain the name of our detached body part ('Breasts', 'Penis', 'Vagina') from a substring of our class name.  Must match Blender!!  ###WEAK?

		if (GetComponent<Collider>() != null)
			Destroy(GetComponent<Collider>());                      //###LEARN: Hugely expensive mesh collider created by the above lines... turn it off!

		//=== Set bounds to infinite so our dynamically-created mesh never has to recalculate bounds ===
		_oMeshNow.bounds = CGame._oBoundsInfinite;          //####IMPROVE: This can hurt performance ####OPT!!
		_oMeshNow.MarkDynamic();        // Docs say "Call this before assigning vertices to get better performance when continually updating mesh"
	}

	public virtual void OnChangeGameMode(EGameModes eGameMode) {
		if (_eGameModeSoftBody == eGameMode)				// Avoid creating / destroying more than once.
			return;

		switch (eGameMode) { 
			case EGameModes.Play:
				//=== Call our C++ side to construct the solid tetra mesh.  We need that to assign tetrapins ===		//###DESIGN!: Major design problem between cutter sent here... can cut cloth too??  (Will have to redesign cutter on C++ side for this problem!)
				_oObj = new CObject(this, 0, typeof(ESoftBody), _sNameSoftBody);        //###IMPROVE: Name of soft body to GUI
				_oObj._hObject = ErosEngine.SoftBody_Create(_oObj._sNameObject, _oObj.GetNumProps(), _memVerts.P, _memVerts.L.Length, _memTris.P, _memTris.L.Length / 3, _memNormals.P, _SoftBodyDetailLevel, .01f, false, false, (int)_eColGroup); //###DESIGN: Density??  ###OBS??
				_oObj.PropGroupBegin("", "", true);
				_oObj.PropAdd(ESoftBody.VolumeStiffness,		"Volume Stiffness",			0.9f,	0.01f,		1, "");   //###CHECK: Can go to zero??
				_oObj.PropAdd(ESoftBody.StretchingStiffness,	"Stretching Stiffness",		0.5f,	0.01f,		1, "");
				_oObj.PropAdd(ESoftBody.SoftBody_Damping,		"Damping Coefficient",		0,		0,			1, "");
				_oObj.PropAdd(ESoftBody.Friction,				"Friction",					0,		0,			1, "");
				_oObj.PropAdd(ESoftBody.SoftBody_Gravity,		"Local Gravity",			-0.5f,	-2,			2, "");
				_oObj.PropAdd(ESoftBody.ParticleRadius,			"Particle Radius",			0.015f, 0.001f,		0.030f, ""); //###TUNE!!!! ###TODO! ###DESIGN!! Override by each softbody??
				_oObj.PropAdd(ESoftBody.SolverIterations,		"Solver Iterations",		1,		1,			6, "Number of times PhysX iterates over this soft body's tetrahedra solid elements per frame.");       //###DESIGN!!! ###TUNE!!!!
				_oObj.PropAdd(ESoftBody.SoftBody_GPU,			"GPU",						1,		"",			CProp.AsCheckbox);  //###TODO!!!: Connect to global settings
				_oObj.FinishInitialization();
				ErosEngine.Object_GoOnline(_oObj._hObject, IntPtr.Zero);

				//=== Ask Blender to create a temporary mesh with the # of tetraverts we have (so we can quickly upload our data without passing mesh as a string) ===
				int nVertTetras = ErosEngine.SoftBody_GetTetraVertCount(_oObj._hObject);                    //####DEV
				string sAccessString_CBody = "CBody_GetBody(" + _oBody._nBodyID.ToString() + ")";					// Simplify access to Blender CBody instance			####MOVE??
				string sAccessString_CSoftBody = "aSoftBodies['" + _sNameSoftBody + "']";							// Simplify access to Blender CSoftBody instance
				string sAccessString_CSoftBody_FullyQualfied = sAccessString_CBody + "." + sAccessString_CSoftBody;	// Simplify access to fully-qualified Blender CSoftBody instance (from CBody instance)

				CGame.gBL_SendCmd("CBody", sAccessString_CSoftBody_FullyQualfied + ".CreateTempMesh(" + nVertTetras.ToString() + ")");     // Ask Blender to create a temporary mesh with just the number of verts we need.
				CBMesh oMeshTetra = CBMesh.Create(null, _oBody, sAccessString_CSoftBody + ".oMeshTemp", typeof(CBMesh));       // Obtain the mesh we just created.  We will fill it with our tetra verts so Blender can skin the pinned ones.

				//=== Upload our tetraverts to Blender so it can select those that are pinned and skin them ===
				for (int nVertTetra = 0; nVertTetra < nVertTetras; nVertTetra++)
					oMeshTetra._memVerts.L[nVertTetra] = ErosEngine.SoftBody_GetTetraVert(_oObj._hObject, nVertTetra);
				oMeshTetra.UpdateVertsToBlenderMesh();				// Blender now has our tetraverts.  It can now find the tetraverts near the rim and skin them

				//=== Create and retrieve the softbody rim mesh responsible to pin softbody to skinned body ===
				CGame.gBL_SendCmd("CBody", sAccessString_CSoftBody_FullyQualfied + ".ProcessTetraVerts(" + _nRangeTetraPinHunt.ToString() + ")");		// Ask Blender select the tetraverts near the rim and skin them
				_oMeshRimBaked = (CBSkinBaked)CBMesh.Create(null, _oBody, sAccessString_CSoftBody + ".oMeshSoftBodyRim", typeof(CBSkinBaked));           // Retrieve the skinned softbody rim mesh Blender just created so we can pin softbody at runtime

				//=== Receive the important 'CSoftBody.aMapRimTetravert2Tetravert' and 'CSoftBody.aMapTwinVerts' array Blender has prepared for softbody-connection to skinned mesh.  (to map the softbody edge vertices to the skinned-body vertices they should attach to)
				CUtility.BlenderSerialize_GetSerializableCollection("'CBody', 'CSoftBody'", sAccessString_CSoftBody_FullyQualfied + ".SerializeCollection('aMapRimTetravert2Tetravert')",	ref _aMapRimTetravert2Tetravert);		// Read the tetravert traversal map from our CSoftBody instance
				CUtility.BlenderSerialize_GetSerializableCollection("'CBody', 'CSoftBody'", sAccessString_CSoftBody_FullyQualfied + ".SerializeCollection('aMapTwinVerts')",				ref _aMapTwinVerts);									// Read the twin-vert traversal map from our CSoftBody instance

				//=== Bake the rim tetramesh a first time so its rim and tetraverts are updated to its skinned body ===
				_oMeshRimBaked.Baking_UpdateBakedMesh();                                        
				break;

			case EGameModes.PlayNoAnim:
				ErosEngine.Object_GoOffline(_oObj._hObject);
				ErosEngine.SoftBody_Destroy(_oObj._hObject);
				Destroy(_oMeshRimBaked);
				_oMeshRimBaked = null;
				_aMapTwinVerts = null;
				_oObj = null;
				_oMeshNow.vertices  = _memVerts.L = _memVertsStart.L;			// Restore the visible mesh to the way it was during first creation  ####DEV: Sufficient?
				break;
		}

		_eGameModeSoftBody = eGameMode;				// Game mode now synced
	}

	public override void OnDestroy() {
		Debug.Log("Destroy CBSoft " + gameObject.name);
		ErosEngine.SoftBody_Destroy(_oObj._hObject);		//###CHECK: Everything destroyed?  Pins, colliders, etc?
		base.OnDestroy();
	}
	
	//---------------------------------------------------------------------------	UPDATE
	
	public virtual void OnSimulatePre() {
		if (Input.GetKeyDown(KeyCode.F10))			//####TEMP			####OBS ####CLEAN
			UpdateVertsFromBlenderMesh(false);
		if (Input.GetKeyDown(KeyCode.F11))			//####TEMP
			OnChangeGameMode(EGameModes.Play);
		if (Input.GetKeyDown(KeyCode.F12))
			OnChangeGameMode(EGameModes.PlayNoAnim);

		switch (_eGameModeSoftBody) {
			case EGameModes.Play:
				_oMeshRimBaked.Baking_UpdateBakedMesh();                                        // Bake the rim tetramesh so its rim and tetraverts are updated to its skinned body.
				Vector3[] aVertsRimBaked = _oMeshRimBaked._oMeshBaked.vertices;		//###LEARN!!!!!: Absolutely IMPERATIVE to obtain whole array before loop like the one below... with individual access profiler reveals 7ms per frame if not!!
				for (int nIndex = 0; nIndex < _aMapRimTetravert2Tetravert.Count; ) {			// Iterate through the rim tetraverts to update the position of their corresponding tetraverts
					ushort nRimTetravert	= _aMapRimTetravert2Tetravert[nIndex++];			// The simple list has been flattened into <nRimTetravert0, nTetravert0>, <nRimTetravert1, nTetravert1>, etc...
					ushort nTetravert		= _aMapRimTetravert2Tetravert[nIndex++];
					ErosEngine.PinTetra_AttachTetraVertToPos(_oObj._hObject, nTetravert, aVertsRimBaked[nRimTetravert]);				// If we're a simple fix we just update to the latest position
				}
				break;
			case EGameModes.PlayNoAnim:
				break;
		}
	}

	public virtual void OnSimulateBetweenPhysX23() {}

	public virtual void OnSimulatePost() {
		switch (_eGameModeSoftBody) {
			case EGameModes.Play:		//=== Update the position and normals of the softbody mesh rim vertices to their equivalent on baked skinned rim mesh.  (This prevents gaps in the two meshes and aligns normals so shading is ok accross the two meshes) ===
				Vector3[] aVertsRimBaked   = _oMeshRimBaked._oMeshBaked.vertices;       //###LEARN!!!!!: Absolutely IMPERATIVE to obtain whole array before loop like the one below... with individual access profiler reveals 7ms per frame if not!!!
				Vector3[] aNormalsRimBaked = _oMeshRimBaked._oMeshBaked.normals;
				for (int nIndex = 0; nIndex < _aMapTwinVerts.Count; ) {			// Iterate through the twin vert flattened map...
					ushort nVertTwinChunk	= _aMapTwinVerts[nIndex++];			// The simple list has been flattened into <nVertTwinChunk0, nVertTwinRim0>, <nVertTwinChunk1, nVertTwinRim1>,  etc...
					ushort nVertTwinRim		= _aMapTwinVerts[nIndex++];
					_memVerts  .L[nVertTwinChunk] = aVertsRimBaked  [nVertTwinRim];
					_memNormals.L[nVertTwinChunk] = aNormalsRimBaked[nVertTwinRim];
				}
				_oMeshNow.vertices  = _memVerts.L;
				_oMeshNow.normals   = _memNormals.L;
				break;
			case EGameModes.PlayNoAnim:
				break;
		}
	}
			
	public void OnPropSet_NeedReset(CProp oProp, float nValueOld, float nValueNew) { }
}
