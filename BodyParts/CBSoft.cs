/*###DISCUSSION: Soft Body / PhysX
=== NEXT ===
 * Cleanup old non-CProp properties

=== TODO ===

=== LATER ===

=== IMPROVE ===

=== DESIGN ===

=== IDEAS ===

=== LEARNED ===

=== PROBLEMS ===
 * GPU on softbody not working!! WTF???  Has to be offline?  Used to work!  ####SOON

=== PROBLEMS??? ===

=== WISHLIST ===

*/

using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;


public class CBSoft : CBMesh, IObject {	// Manages a single soft body object send to our PhysX implementation for soft body simulation.  These 'body parts' (such as breasts, penis, vagina) 
	//... are conneted to the main body skinned mesh via _oMeshRimBaked which pins this softbody's tetraverts to those skinned from the main body

	//---------------------------------------------------------------------------	MEMBERS
	[HideInInspector]	public 	CObject				_oObj;						// The multi-purpose CObject that stores CProp properties  to publicly define our object.  Provides client/server, GUI and scripting access to each of our 'super public' properties.
	
	[HideInInspector]	public	List<ushort>		_aMapTwinVerts = new List<ushort>();		// Collection of mapping between our verts and the verts of our BodyRim.  Used to set softbody mesh rim verts and normals to their skinned-equivalent
	
	//---------------------------------------------------------------------------	PhysX-related properties sent during BSoft_Init()
						public	string				_sNameDetachChunk;				// The name of our 'detached chunk' in Blender.  ('Breasts', 'Penis', 'Vagina') from a substring of our class name.  Must match Blender!!
						public  int					_SoftBodyDetailLevel;			// Detail level of the associated PhysX tetramesh... a range between 20 (low) and 50 (very high) is reasonable
	[HideInInspector]	public	EColGroups			_eColGroup;						// The PhysX collider group for this softbody.  Used to properly determine what this softbody collides with...
	[HideInInspector]	public	float				_nRangeTetraPinHunt = 0.025f;	// The maximum distance between the rim mesh and the tetraverts generated by PhysX2.  Determins which softbody tetraverts are 'pinned' to the skinned body
	[HideInInspector]	public	List<ushort>		_aMapRimTetravert2Tetravert;	// Map of rim tetraverts to tetraverts.  Used to translate between our 'rim + close tetraverts' to PhysX2 softbody tetraverts. (To pin some tetraverts to skinned body)

	[HideInInspector]	public	CBSkinBaked			_oMeshRimBaked;					// The skinned 'rim mesh' that is baked everyframe.  Contains rim and tetraverts.  Rim is to adjust normals at softbody mesh boundary and the tetraverts in this mesh are to 'pin' our softbody tetraverts to the skinned body (so softbody doesn't go 'flying off')

	//---------------------------------------------------------------------------	MISC
						public const float 			C_DistBSoftMesh2SkinnedMesh = 0.001f;               // Maximum allowed distance between a vert on a softbody and the nearby vert on skinned-side for them to be considered 'joined'  ###WEAK: Made larger because of right breast!

	public bool _bDisableSoftBodySimulation_HACK = false;


	//---------------------------------------------------------------------------	INIT

	public CBSoft() {                           // Setup the default arguments... usually overriden by our derived class   //###BUG??? Why are these settings not overriding those in instanced node???
		_nRangeTetraPinHunt = 0.025f;
	}


	public override void OnDeserializeFromBlender() {
		base.OnDeserializeFromBlender();

		_sNameDetachChunk = GetType().Name.Substring(1);							// Obtain the name of our detached body part ('Breasts', 'Penis', 'Vagina') from a substring of our class name.  Must match Blender!!  ###WEAK?
		_oObj = new CObject(this, 0, typeof(ESoftBody), _sNameDetachChunk);        //###IMPROVE: Name of soft body to GUI

		_oMeshNow.MarkDynamic();        // Docs say "Call this before assigning vertices to get better performance when continually updating mesh"

		if (GetComponent<Collider>() != null)
			Destroy(GetComponent<Collider>());                      //###LEARN: Hugely expensive mesh collider created by the above lines... turn it off!

		//=== Call our C++ side to construct the solid tetra mesh.  We need that to assign tetrapins ===		//###DESIGN!: Major design problem between cutter sent here... can cut cloth too??  (Will have to redesign cutter on C++ side for this problem!)
		_oObj._hObject = ErosEngine.SoftBody_Create(_oObj._sNameObject, _oObj.GetNumProps(), _memVerts.P, _memVerts.L.Length, _memTris.P, _memTris.L.Length / 3, _memNormals.P, _SoftBodyDetailLevel, .01f, false, false, (int)_eColGroup); //###DESIGN: Density??  ###OBS??

		_oObj.PropGroupBegin("", "", true);
		_oObj.PropAdd(ESoftBody.VolumeStiffness,		"Volume Stiffness",			0.9f, 0.01f, 1, "");   //###CHECK: Can go to zero??
		_oObj.PropAdd(ESoftBody.StretchingStiffness,	"Stretching Stiffness",		0.5f, 0.01f, 1, "");
		_oObj.PropAdd(ESoftBody.SoftBody_Damping,		"Damping Coefficient",		0, 0, 1, "");
		_oObj.PropAdd(ESoftBody.Friction,				"Friction",					0, 0, 1, "");
		_oObj.PropAdd(ESoftBody.SoftBody_Gravity,		"Local Gravity",			-0.5f, -2, 2, "");
		_oObj.PropAdd(ESoftBody.ParticleRadius,			"Particle Radius",			0.015f, 0.001f, 0.030f, ""); //###TUNE!!!! ###TODO! ###DESIGN!! Override by each softbody??
		_oObj.PropAdd(ESoftBody.SolverIterations,		"Solver Iterations",		1, 1, 6, "Number of times PhysX iterates over this soft body's tetrahedra solid elements per frame.");       //###DESIGN!!! ###TUNE!!!!
		_oObj.PropAdd(ESoftBody.SoftBody_GPU,			"GPU",						1, "", CProp.AsCheckbox);  //###TODO!!!: Connect to global settings
		_oObj.FinishInitialization();

		ErosEngine.Object_GoOnline(_oObj._hObject, IntPtr.Zero);

		//=== Now that PhysX has constructed the tetramesh, we can complete the initialization by connecting our skinned pins to tetrahedron pins so the softbody solid is moved by our skinned mesh host ===
		//####DEV ConnectPinsToTetraMesh();

		//=== Ask Blender to create a temporary mesh with the # of tetraverts we have (so we can quickly upload our data without passing mesh as a string) ===
		int nVertTetras = ErosEngine.SoftBody_GetTetraVertCount(_oObj._hObject);					//####DEV
		CGame.gBL_SendCmd("CBody", "CBody_GetBody(" + _oBody._nBodyID.ToString() + ").CreateTempMesh(" + nVertTetras.ToString() + ")");     // Ask Blender to create a temporary mesh with just the number of verts we need.
		CBMesh oMeshTetra = CBMesh.Create(null, _oBody, "oMeshTemp", typeof(CBMesh));       // Obtain the mesh we just created.  We will fill it with our tetra verts so Blender can skin the pinned ones.

		//=== Upload our tetraverts to Blender so it can select those that are pinned and skin them ===
		for (int nVertTetra = 0; nVertTetra < nVertTetras; nVertTetra++)
			oMeshTetra._memVerts.L[nVertTetra] = ErosEngine.SoftBody_GetTetraVert(_oObj._hObject, nVertTetra);
		oMeshTetra.UpdateVertsToBlenderMesh();				// Blender now has our tetraverts.  It can now find the tetraverts near the rim and skin them

		//=== Create and retrieve the softbody rim mesh responsible to pin softbody to skinned body ===
		CGame.gBL_SendCmd("CBody", "CBody_GetBody(" + _oBody._nBodyID.ToString() + ").SoftBody_CreateSoftBodyRimMesh('" + _sNameDetachChunk + "'," + _nRangeTetraPinHunt.ToString() + ")");		// Ask Blender select the tetraverts near the rim and skin them
		_oMeshRimBaked = (CBSkinBaked)CBMesh.Create(null, _oBody, "aMeshSoftBodiesRim['" + _sNameDetachChunk + "']", typeof(CBSkinBaked));           // Retrieve the skinned softbody rim mesh Blender just created so we can pin softbody at runtime
		_oMeshRimBaked.GetBlenderMeshArray("aMapRimTetravert2Tetravert", ref _aMapRimTetravert2Tetravert);			// Read the tetravert traversal map so we can map the rim tetraverts to the PhysX2 tetraverts at runtime

		////=== Receive the important 'aMapTwinVerts' array Blender has prepared for softbody-connection to skinned mesh.  (to map the softbody edge vertices to the skinned-body vertices they should attach to.)  Only present on softbody Blender meshes!
		_oMeshRimBaked.GetBlenderMeshArray("aMapTwinVerts", ref _aMapTwinVerts);			// Read the tetravert traversal map so we can map the rim tetraverts to the PhysX2 tetraverts at runtime

		//=== Set bounds to infinite so our dynamically-created mesh never has to recalculate bounds ===
		_oMeshNow.bounds = CGame._oBoundsInfinite;			//####IMPROVE: This can hurt performance ####OPT!!
	}

	public override void OnDestroy() {
		Debug.Log("Destroy CBSoft " + gameObject.name);
		ErosEngine.SoftBody_Destroy(_oObj._hObject);		//###CHECK: Everything destroyed?  Pins, colliders, etc?
		base.OnDestroy();
	}
	
	//---------------------------------------------------------------------------	UPDATE
	
	public virtual void OnSimulatePre() {		
		if (_bDisableSoftBodySimulation_HACK)
			return;
		_oMeshRimBaked.Baking_UpdateBakedMesh();                                        // Bake the rim tetramesh so its rim and tetraverts are updated to its skinned body.
		Vector3[] aVertsRimBaked = _oMeshRimBaked._oMeshBaked.vertices;		//###LEARN!!!!!: Absolutely IMPERATIVE to obtain whole array before loop like the one below... with individual access profiler reveals 7ms per frame if not!!
		for (int nIndex = 0; nIndex < _aMapRimTetravert2Tetravert.Count; ) {			// Iterate through the rim tetraverts to update the position of their corresponding tetraverts
			ushort nRimTetravert	= _aMapRimTetravert2Tetravert[nIndex++];			// The simple list has been flattened into <nRimTetravert0, nTetravert0>, <nRimTetravert1, nTetravert1>, etc...
			ushort nTetravert		= _aMapRimTetravert2Tetravert[nIndex++];
			ErosEngine.PinTetra_AttachTetraVertToPos(_oObj._hObject, nTetravert, aVertsRimBaked[nRimTetravert]);				// If we're a simple fix we just update to the latest position
		}
	}

	public virtual void OnSimulateBetweenPhysX23() {}

	public virtual void OnSimulatePost() {
		if (_bDisableSoftBodySimulation_HACK) {
			if (Input.GetKeyDown(KeyCode.F12))			//####TEMP			####OBS ####CLEAN
				UpdateVertsFromBlenderMesh(false);
			if (Input.GetKeyDown(KeyCode.F11))			//####TEMP
				_oMeshNow.vertices  = _memVertsStart.L;			//####DEV: Just show the start vertices when not simulated
		} else {
			//=== Update the position and normals of the softbody mesh rim vertices to their equivalent on baked skinned rim mesh.  (This prevents gaps in the two meshes and aligns normals so shading is ok accross the two meshes) ===
			Vector3[] aVertsRimBaked   = _oMeshRimBaked._oMeshBaked.vertices;       //###LEARN!!!!!: Absolutely IMPERATIVE to obtain whole array before loop like the one below... with individual access profiler reveals 7ms per frame if not!!!
			Vector3[] aNormalsRimBaked = _oMeshRimBaked._oMeshBaked.normals;
			for (int nIndex = 0; nIndex < _aMapTwinVerts.Count; ) {			// Iterate through the twin vert flattened map...
				ushort nVertTwinChunk	= _aMapTwinVerts[nIndex++];			// The simple list has been flattened into <nVertTwinChunk0, nVertTwinRim0>, <nVertTwinChunk1, nVertTwinRim1>,  etc...
				ushort nVertTwinRim		= _aMapTwinVerts[nIndex++];
				_memVerts  .L[nVertTwinChunk] = aVertsRimBaked  [nVertTwinRim];
				_memNormals.L[nVertTwinChunk] = aNormalsRimBaked[nVertTwinRim];
			}
			_oMeshNow.vertices  = _memVerts.L;
			_oMeshNow.normals   = _memNormals.L;
		}
	}
			
	public void OnPropSet_NeedReset(CProp oProp, float nValueOld, float nValueNew) { }

}
